{"aliases":["modernizr:promises","caniuse:promises"],"browsers":{"android":"* - 4.4","bb":"* - 10","chrome":"* - 31","firefox":"6 - 28","ie":"8 - *","ie_mob":"*","ios_saf":"* - 7.1","op_mini":"*","opera":"* - 19","safari":"* - 7","firefox_mob":"6 - 28"},"dependencies":["setImmediate","Array.isArray"],"notes":["In IE8, the `catch` method cannot be invoked directly since it is a reserved word.  Instead, use `[\"catch\"]` if intend to run your code in IE8"],"license":"MIT","docs":"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise","repo":"https://github.com/Octane/Promise","baseDir":"Promise","hasTests":true,"rawSource":"\n// Promise\n/**\n * Promise polyfill v1.0.10\n * requires setImmediate\n *\n * © 2014–2015 Dmitry Korobkin\n * Released under the MIT license\n * github.com/Octane/Promise\n */\n(function (global) {'use strict';\n\n    var STATUS = '[[PromiseStatus]]';\n    var VALUE = '[[PromiseValue]]';\n    var ON_FUlFILLED = '[[OnFulfilled]]';\n    var ON_REJECTED = '[[OnRejected]]';\n    var ORIGINAL_ERROR = '[[OriginalError]]';\n    var PENDING = 'pending';\n    var INTERNAL_PENDING = 'internal pending';\n    var FULFILLED = 'fulfilled';\n    var REJECTED = 'rejected';\n    var NOT_ARRAY = 'not an array.';\n    var REQUIRES_NEW = 'constructor Promise requires \"new\".';\n    var CHAINING_CYCLE = 'then() cannot return same Promise that it resolves.';\n\n    // Modifed by polyfill service - remove undefined require statement\n    var setImmediate = global.setImmediate;\n\n    var isArray = Array.isArray || function (anything) {\n        return Object.prototype.toString.call(anything) == '[object Array]';\n    };\n\n    function InternalError(originalError) {\n        this[ORIGINAL_ERROR] = originalError;\n    }\n\n    function isInternalError(anything) {\n        return anything instanceof InternalError;\n    }\n\n    function isObject(anything) {\n        //Object.create(null) instanceof Object → false\n        return Object(anything) === anything;\n    }\n\n    function isCallable(anything) {\n        return typeof anything == 'function';\n    }\n\n    function isPromise(anything) {\n        return anything instanceof Promise;\n    }\n\n    function identity(value) {\n        return value;\n    }\n\n    function thrower(reason) {\n        throw reason;\n    }\n\n    function enqueue(promise, onFulfilled, onRejected) {\n        if (!promise[ON_FUlFILLED]) {\n            promise[ON_FUlFILLED] = [];\n            promise[ON_REJECTED] = [];\n        }\n        promise[ON_FUlFILLED].push(onFulfilled);\n        promise[ON_REJECTED].push(onRejected);\n    }\n\n    function clearAllQueues(promise) {\n        delete promise[ON_FUlFILLED];\n        delete promise[ON_REJECTED];\n    }\n\n    function callEach(queue) {\n        var i;\n        var length = queue.length;\n        for (i = 0; i < length; i++) {\n            queue[i]();\n        }\n    }\n\n    function call(resolve, reject, value) {\n        var anything = toPromise(value);\n        if (isPromise(anything)) {\n            anything.then(resolve, reject);\n        } else if (isInternalError(anything)) {\n            reject(anything[ORIGINAL_ERROR]);\n        } else {\n            resolve(value);\n        }\n    }\n\n    function toPromise(anything) {\n        var then;\n        if (isPromise(anything)) {\n            return anything;\n        }\n        if(isObject(anything)) {\n            try {\n                then = anything.then;\n            } catch (error) {\n                return new InternalError(error);\n            }\n            if (isCallable(then)) {\n                return new Promise(function (resolve, reject) {\n                    setImmediate(function () {\n                        try {\n                            then.call(anything, resolve, reject);\n                        } catch (error) {\n                            reject(error);\n                        }\n                    });\n                });\n            }\n        }\n        return null;\n    }\n\n    function resolvePromise(promise, resolver) {\n        function resolve(value) {\n            if (promise[STATUS] == PENDING) {\n                fulfillPromise(promise, value);\n            }\n        }\n        function reject(reason) {\n            if (promise[STATUS] == PENDING) {\n                rejectPromise(promise, reason);\n            }\n        }\n        try {\n            resolver(resolve, reject);\n        } catch(error) {\n            reject(error);\n        }\n    }\n\n    function fulfillPromise(promise, value) {\n        var queue;\n        var anything = toPromise(value);\n        if (isPromise(anything)) {\n            promise[STATUS] = INTERNAL_PENDING;\n            anything.then(\n                function (value) {\n                    fulfillPromise(promise, value);\n                },\n                function (reason) {\n                    rejectPromise(promise, reason);\n                }\n            );\n        } else if (isInternalError(anything)) {\n            rejectPromise(promise, anything[ORIGINAL_ERROR]);\n        } else {\n            promise[STATUS] = FULFILLED;\n            promise[VALUE] = value;\n            queue = promise[ON_FUlFILLED];\n            if (queue && queue.length) {\n                clearAllQueues(promise);\n                callEach(queue);\n            }\n        }\n    }\n\n    function rejectPromise(promise, reason) {\n        var queue = promise[ON_REJECTED];\n        promise[STATUS] = REJECTED;\n        promise[VALUE] = reason;\n        if (queue && queue.length) {\n            clearAllQueues(promise);\n            callEach(queue);\n        }\n    }\n\n    function Promise(resolver) {\n        var promise = this;\n        if (!isPromise(promise)) {\n            throw new TypeError(REQUIRES_NEW);\n        }\n        promise[STATUS] = PENDING;\n        promise[VALUE] = undefined;\n        resolvePromise(promise, resolver);\n    }\n\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n        var promise = this;\n        var nextPromise;\n        onFulfilled = isCallable(onFulfilled) ? onFulfilled : identity;\n        onRejected = isCallable(onRejected) ? onRejected : thrower;\n        nextPromise = new Promise(function (resolve, reject) {\n            function tryCall(func) {\n                var value;\n                try {\n                    value = func(promise[VALUE]);\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (value === nextPromise) {\n                    reject(new TypeError(CHAINING_CYCLE));\n                } else {\n                    call(resolve, reject, value);\n                }\n            }\n            function asyncOnFulfilled() {\n                setImmediate(tryCall, onFulfilled);\n            }\n            function asyncOnRejected() {\n                setImmediate(tryCall, onRejected);\n            }\n            switch (promise[STATUS]) {\n                case FULFILLED:\n                    asyncOnFulfilled();\n                    break;\n                case REJECTED:\n                    asyncOnRejected();\n                    break;\n                default:\n                    enqueue(promise, asyncOnFulfilled, asyncOnRejected);\n            }\n        });\n        return nextPromise;\n    };\n\n    Promise.prototype['catch'] = function (onRejected) {\n        return this.then(identity, onRejected);\n    };\n\n    Promise.resolve = function (value) {\n        var anything = toPromise(value);\n        if (isPromise(anything)) {\n            return anything;\n        }\n        return new Promise(function (resolve, reject) {\n            if (isInternalError(anything)) {\n                reject(anything[ORIGINAL_ERROR]);\n            } else {\n                resolve(value);\n            }\n        });\n    };\n\n    Promise.reject = function (reason) {\n        return new Promise(function (resolve, reject) {\n            reject(reason);\n        });\n    };\n\n    Promise.race = function (values) {\n        return new Promise(function (resolve, reject) {\n            var i;\n            var length;\n            if (isArray(values)) {\n                length = values.length;\n                for (i = 0; i < length; i++) {\n                    call(resolve, reject, values[i]);\n                }\n            } else {\n                reject(new TypeError(NOT_ARRAY));\n            }\n        });\n    };\n\n    Promise.all = function (values) {\n        return new Promise(function (resolve, reject) {\n            var fulfilledCount = 0;\n            var promiseCount = 0;\n            var anything;\n            var length;\n            var value;\n            var i;\n            if (isArray(values)) {\n                values = values.slice(0);\n                length = values.length;\n                for (i = 0; i < length; i++) {\n                    value = values[i];\n                    anything = toPromise(value);\n                    if (isPromise(anything)) {\n                        promiseCount++;\n                        anything.then(\n                            function (index) {\n                                return function (value) {\n                                    values[index] = value;\n                                    fulfilledCount++;\n                                    if (fulfilledCount == promiseCount) {\n                                        resolve(values);\n                                    }\n                                };\n                            }(i),\n                            reject\n                        );\n                    } else if (isInternalError(anything)) {\n                        reject(anything[ORIGINAL_ERROR]);\n                    } else {\n                        //[1, , 3] → [1, undefined, 3]\n                        values[i] = value;\n                    }\n                }\n                if (!promiseCount) {\n                    resolve(values);\n                }\n            } else {\n                reject(new TypeError(NOT_ARRAY));\n            }\n        });\n    };\n\n    if (typeof module != 'undefined' && module.exports) {\n        module.exports = global.Promise || Promise;\n    } else if (!global.Promise) {\n        global.Promise = Promise;\n    }\n\n}(this));\n","minSource":"!function(n){\"use strict\";function t(n){this[j]=n}function e(n){return n instanceof t}function r(n){return Object(n)===n}function o(n){return\"function\"==typeof n}function i(n){return n instanceof v}function u(n){return n}function c(n){throw n}function f(n,t,e){n[g]||(n[g]=[],n[P]=[]),n[g].push(t),n[P].push(e)}function a(n){delete n[g],delete n[P]}function s(n){var t,e=n.length;for(t=0;e>t;t++)n[t]()}function l(n,t,r){var o=h(r);i(o)?o.then(n,t):e(o)?t(o[j]):n(r)}function h(n){var e;if(i(n))return n;if(r(n)){try{e=n.then}catch(u){return new t(u)}if(o(e))return new v(function(t,r){S(function(){try{e.call(n,t,r)}catch(o){r(o)}})})}return null}function p(n,t){function e(t){n[w]==b&&d(n,t)}function r(t){n[w]==b&&y(n,t)}try{t(e,r)}catch(o){r(o)}}function d(n,t){var r,o=h(t);i(o)?(n[w]=E,o.then(function(t){d(n,t)},function(t){y(n,t)})):e(o)?y(n,o[j]):(n[w]=O,n[m]=t,r=n[g],r&&r.length&&(a(n),s(r)))}function y(n,t){var e=n[P];n[w]=T,n[m]=t,e&&e.length&&(a(n),s(e))}function v(n){var t=this;if(!i(t))throw new TypeError(k);t[w]=b,t[m]=void 0,p(t,n)}var w=\"[[PromiseStatus]]\",m=\"[[PromiseValue]]\",g=\"[[OnFulfilled]]\",P=\"[[OnRejected]]\",j=\"[[OriginalError]]\",b=\"pending\",E=\"internal pending\",O=\"fulfilled\",T=\"rejected\",A=\"not an array.\",k='constructor Promise requires \"new\".',x=\"then() cannot return same Promise that it resolves.\",S=n.setImmediate,q=Array.isArray||function(n){return\"[object Array]\"==Object.prototype.toString.call(n)};v.prototype.then=function(n,t){var e,r=this;return n=o(n)?n:u,t=o(t)?t:c,e=new v(function(o,i){function u(n){var t;try{t=n(r[m])}catch(u){return void i(u)}t===e?i(new TypeError(x)):l(o,i,t)}function c(){S(u,n)}function a(){S(u,t)}switch(r[w]){case O:c();break;case T:a();break;default:f(r,c,a)}})},v.prototype[\"catch\"]=function(n){return this.then(u,n)},v.resolve=function(n){var t=h(n);return i(t)?t:new v(function(r,o){e(t)?o(t[j]):r(n)})},v.reject=function(n){return new v(function(t,e){e(n)})},v.race=function(n){return new v(function(t,e){var r,o;if(q(n))for(o=n.length,r=0;o>r;r++)l(t,e,n[r]);else e(new TypeError(A))})},v.all=function(n){return new v(function(t,r){var o,u,c,f,a=0,s=0;if(q(n)){for(n=n.slice(0),u=n.length,f=0;u>f;f++)c=n[f],o=h(c),i(o)?(s++,o.then(function(e){return function(r){n[e]=r,a++,a==s&&t(n)}}(f),r)):e(o)?r(o[j]):n[f]=c;s||t(n)}else r(new TypeError(A))})},\"undefined\"!=typeof module&&module.exports?module.exports=n.Promise||v:n.Promise||(n.Promise=v)}(this);","detectSource":"'Promise' in this"}