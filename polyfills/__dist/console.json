{"aliases":["caniuse:console-basic"],"browsers":{"ie":"6 - 11","firefox":"1 - 4"},"dependencies":["Window"],"spec":"https://github.com/DeveloperToolsWG/console-object/blob/master/api.md","docs":"https://developer.mozilla.org/en/docs/Web/API/console","baseDir":"console","hasTests":true,"rawSource":"\n// console\n(function(global) {\n\n\t// Grab a referecnce to the console or assign one if it does not exist.\n\tvar console = global.console || (global.console = {});\n\n\tfunction noop () {}\n\n\t// This is based off of angular's internal log factory.\n\tfunction factory(type) {\n\n\t\tvar fn = console[type] || console.log || noop;\n\t\tvar hasApply = false;\n\n\t\t// Reading `fn.apply` throws in IE11  in IE8 mode. This is because\n\t\t// `typeof console.log === \"object\"` in IE8\n\t\ttry {\n\t\t\thasApply = !!fn.apply;\n\t\t} catch (e) { /* do nothing */ }\n\n\t\t// Check if we can safely use `fn.apply`.\n\t\tif (hasApply) {\n\t\t\treturn function () {\n\t\t\t\tfn.apply(console, arguments);\n\t\t\t};\n\t\t}\n\n\t\t// If we are here it means that `console[type]` does not have an\n\t\t// `apply` method. So instead we log out the first 3 arguments.\n\t\treturn function (arg1, arg2, arg3) {\n\t\t\tfn(arg1, arg2, arg3);\n\t\t};\n\n\t}\n\n\t// The properties to polyfill.\n\tvar properties = [\n\t\t'memory'\n\t];\n\n\t// The methods to polyfill.\n\tvar methods = [\n\t\t'log',\n\t\t'assert',\n\t\t'cd',\n\t\t'clear',\n\t\t'count',\n\t\t'debug',\n\t\t'dir',\n\t\t'error',\n\t\t'exception',\n\t\t'group',\n\t\t'groupCollapsed',\n\t\t'groupEnd',\n\t\t'info',\n\t\t'markTimeline',\n\t\t'profile',\n\t\t'profileEnd',\n\t\t'profiles',\n\t\t'show',\n\t\t'table',\n\t\t'time',\n\t\t'timeEnd',\n\t\t'timeStamp',\n\t\t'timeline',\n\t\t'timelineEnd',\n\t\t'trace',\n\t\t'warn'\n\t];\n\n\tvar index, method, property;\n\tvar empty = {};\n\n\t// Polyfill the properties.\n\tfor (index = 0; index < properties.length; index++) {\n\t\tproperty = properties[index];\n\t\tif (!(property in console)) {\n\t\t\tconsole[property] = empty;\n\t\t}\n\t}\n\n\t// Polyfill the methods.\n\tfor (index = 0; index < methods.length; index++) {\n\t\tmethod = methods[index];\n\t\tif (typeof console[method] !== 'function') {\n\t\t\tconsole[method] = factory(method);\n\t\t}\n\t}\n\n})(this);\n","minSource":"!function(n){function e(){}function o(n){var o=l[n]||l.log||e,t=!1;try{t=!!o.apply}catch(r){}return t?function(){o.apply(l,arguments)}:function(n,e,t){o(n,e,t)}}var t,r,i,l=n.console||(n.console={}),c=[\"memory\"],a=[\"log\",\"assert\",\"cd\",\"clear\",\"count\",\"debug\",\"dir\",\"error\",\"exception\",\"group\",\"groupCollapsed\",\"groupEnd\",\"info\",\"markTimeline\",\"profile\",\"profileEnd\",\"profiles\",\"show\",\"table\",\"time\",\"timeEnd\",\"timeStamp\",\"timeline\",\"timelineEnd\",\"trace\",\"warn\"],p={};for(t=0;t<c.length;t++)i=c[t],i in l||(l[i]=p);for(t=0;t<a.length;t++)r=a[t],\"function\"!=typeof l[r]&&(l[r]=o(r))}(this);","detectSource":"'console' in this && 'clear' in this.console && 'markTimeline' in this.console"}